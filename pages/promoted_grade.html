<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>e알리미 진급 파일 자동 매칭기 (로컬 실행)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 18px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px 16px; margin-bottom: 14px; }
    .title { font-size: 18px; font-weight: 800; margin-bottom: 6px; }
    .sub { color:#444; line-height:1.5; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    label { font-weight: 700; }
    input[type=file] { padding: 6px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #bbb; background: #fff; cursor: pointer; }
    button.primary { background: #1f6feb; border-color: #1f6feb; color: #fff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .status { margin-top: 10px; padding: 10px 12px; border-radius: 10px; background: #f6f6f6; }
    .ok { color: #0a7a0a; font-weight: 700; }
    .err { color: #b00020; font-weight: 700; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; white-space: pre-wrap; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; font-size: 12px; }
    th { background: #fafafa; text-align: left; }
    .small { font-size: 12px; color:#666; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#eee; margin-left: 6px; font-size: 12px; }
    h3 { font-size: 14px; }
    h4 { font-size: 13px; }
  </style>

  <!-- 라이브러리 (CDN) -->
  <!-- XLSX: 엑셀 파싱 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- PapaParse: CSV 파싱/생성 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- encoding-japanese: CP949 인코딩 지원 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.1.0/encoding.min.js"></script>
  <!-- iconv-lite 브라우저 버전 (jsdelivr CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/iconv-lite@0.6.3/lib/index.min.js"></script>
</head>

<body>
  <div class="card">
    <div class="title">e알리미 진급 파일 자동 매칭기 <span class="pill">로컬 브라우저 실행</span></div>
    <div class="sub">
      1) 학교 진급명렬 업로드 → 2) e알리미 양식 업로드 → 3) 실행 → 4) CSV 다운로드<br/>
      업로드 파일: <b>xlsx/csv</b> / 결과 파일: <b>CSV(쉼표 구분) 4개</b><br/>
      <span class="small">※ 데이터는 외부 전송 없이 이 브라우저에서만 처리됩니다.</span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div style="flex:1; min-width:320px;">
        <label>1차 업로드(학교 진급명렬)</label><br/>
        <input id="schoolFile" type="file" accept=".xlsx,.xls,.csv" />
        <div id="schoolInfo" class="small"></div>
        <div class="small">
          규칙: 컬럼명이 무엇이든 상관없이 <b>앞 7개 컬럼 위치</b>를 아래 의미로 고정합니다.<br/>
          1:학생이름, 2:이전학년, 3:이전반, 4:이전번호, 5:진급학년, 6:진급반, 7:진급번호
        </div>
      </div>

      <div style="flex:1; min-width:320px;">
        <label>2차 업로드(e알리미 양식)</label><br/>
        <input id="ealimiFile" type="file" accept=".xlsx,.xls,.csv" />
        <div id="ealimiInfo" class="small"></div>
        <div class="small">
          조건: e알리미 양식에 <b>학년/반</b> 컬럼이 각 2개 이상 있어야 합니다(뒤쪽 2번째 세트를 채웁니다).<br/>
          번호 컬럼은 <b>전화번호/연락처 계열을 제외</b>하고 자동 인식합니다(학급번호 우선).
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <button id="runBtn" class="primary" disabled>실행</button>
      <button id="resetBtn">초기화</button>
      <div id="runStatus" class="status" style="flex:1;">대기 중</div>
    </div>
  </div>

  <div class="card">
    <div class="title">결과 다운로드</div>
    <div class="row">
      <button id="dlUpload" disabled>진급_업로드용(매칭행만) 다운로드</button>
      <button id="dlReport" disabled>진급_매칭리포트 다운로드</button>
      <button id="dlMissing" disabled>진급누락목록 다운로드</button>
      <!-- 롤백파일 다운로드 버튼 추가 -->
      <button id="dlRollback" disabled>롤백파일 다운로드</button>
    </div>
    <div id="resultSummary" class="status" style="margin-top:12px;">실행 후 결과 요약이 표시됩니다.</div>
    <table style="margin-top:10px;">
      <thead><tr><th>파일</th><th>설명</th><th>사용 목적</th></tr></thead>
      <tbody>
        <tr>
          <td><b>진급_업로드용(매칭행만)</b></td>
          <td>매칭 성공한 행만 남김. 빈 열 자동 삭제. EUC-KR 인코딩.</td>
          <td><b>e알리미 진급 페이지 업로드</b></td>
        </tr>
        <tr>
          <td><b>진급_매칭리포트</b></td>
          <td>파싱된 학년/반/번호와 상태(매칭/미매칭 사유) 기록</td>
          <td>검수 및 원인분석</td>
        </tr>
        <tr>
          <td><b>진급누락목록</b></td>
          <td>e알리미 명단 중 누락 + 진급명렬 중 누락 (졸업생 제외)</td>
          <td>누락 보정/추적</td>
        </tr>
        <tr>
          <td><b>롤백파일</b></td>
          <td>업로드용 파일의 학년/반/번호를 원래대로 교환</td>
          <td>잘못된 업로드 복구</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="card">
    <div class="title">미리보기</div>
    <div class="small">업로드용(매칭행만) 상위 5행 / 누락목록 상위 10행</div>
    <div id="previewArea"></div>
  </div>

  

<script>
/* =========================
   0) 유틸
========================= */
function clean(x){
  if (x === null || x === undefined) return "";
  return String(x).trim();
}
function normCol(x){
  return clean(x).replace(/\s+/g, "");
}
function stripPandasDupSuffix(name){
  return String(name).replace(/\.\d+$/g, "");
}
function toIntOrNull(x){
  const s = clean(x);
  if (!s) return null;
  const n = parseInt(s, 10);
  return Number.isFinite(n) ? n : null;
}
function startsWithMatched(status){
  return String(status || "").startsWith("매칭");
}
function nowStamp(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}

const CP949_ENCODE_MAP = new Map();
let cp949MapInitialized = false;

async function initCP949Map() {
  if (cp949MapInitialized) return;
  
  // TextDecoder를 사용하여 CP949 -> 유니코드 매핑을 역으로 구축
  try {
    const decoder = new TextDecoder('euc-kr', { fatal: false });
    
    // CP949 바이트 범위 스캔
    // 첫 바이트: 0x81-0xFE
    // 두 번째 바이트: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE
    for (let b1 = 0x81; b1 <= 0xFE; b1++) {
      for (let b2 = 0x41; b2 <= 0xFE; b2++) {
        // 유효하지 않은 두 번째 바이트 스킵
        if (b2 > 0x5A && b2 < 0x61) continue;
        if (b2 > 0x7A && b2 < 0x81) continue;
        
        const bytes = new Uint8Array([b1, b2]);
        const char = decoder.decode(bytes);
        
        // 유효한 문자이고 대체 문자가 아닌 경우
        if (char && char.length === 1 && char !== '\uFFFD' && char.charCodeAt(0) >= 0x80) {
          CP949_ENCODE_MAP.set(char, [b1, b2]);
        }
      }
    }
    
    cp949MapInitialized = true;
    console.log('CP949 매핑 테이블 초기화 완료:', CP949_ENCODE_MAP.size, '문자');
  } catch (e) {
    console.error('CP949 매핑 테이블 초기화 실패:', e);
  }
}

// 페이지 로드 시 CP949 테이블 초기화
initCP949Map();

function convertToCP949(str) {
  const result = [];
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    const code = char.charCodeAt(0);
    
    if (code < 0x80) {
      // ASCII
      result.push(code);
    } else {
      const cp949Bytes = CP949_ENCODE_MAP.get(char);
      if (cp949Bytes) {
        result.push(cp949Bytes[0], cp949Bytes[1]);
      } else {
        // 매핑되지 않는 문자는 '?'로 대체
        result.push(0x3F);
      }
    }
  }
  
  return new Uint8Array(result);
}

/* =========================
   5) e알리미 컬럼 찾기
   - 학년/반: 2세트 필수
   - 번호: 선택사항 (없으면 null)
========================= */
function findEalimiColumns(headers){
  let nameIdx = null;
  const gradeIdxs = [];
  const classIdxs = [];
  const numIdxs = [];
  const numIdxsPrefer = [];

  for(let i=0; i<headers.length; i++){
    const nc = normCol(headers[i]);
    const ncRaw = headers[i];
    if(nameIdx === null && (nc.includes("이름") || nc === "학생명" || nc === "성명")) nameIdx = i;
    if(nc.includes("학년") && !nc.includes("신") && !nc.includes("학년도")) gradeIdxs.push(i);
    if(nc.includes("반") && !nc.includes("신") && !nc.includes("반장")) classIdxs.push(i);

    const isPhone = ncRaw.includes("전화번호") || ncRaw.includes("휴대폰") || ncRaw.includes("연락처");
    if((nc.includes("번호") || nc.includes("출석번호") || nc.includes("학급번호")) && !isPhone){
      numIdxs.push(i);
      if(nc.includes("학급번호") || nc.includes("출석번호")){
        numIdxsPrefer.push(i);
      }
    }
  }

  if(nameIdx === null){
    throw new Error("e알리미 양식에서 '이름/학생명/성명' 컬럼을 찾지 못했습니다.");
  }
  if(gradeIdxs.length < 2 || classIdxs.length < 2){
    throw new Error("e알리미 양식에서 '학년/반' 컬럼이 2세트(각각 2개 이상)로 감지되지 않습니다.");
  }
  
  const chosenNums = (numIdxsPrefer.length ? numIdxsPrefer : numIdxs);
  let cur_n = null;
  let nxt_n = null;
  let hasNumColumn = chosenNums.length > 0;

  if(chosenNums.length >= 2){
    cur_n = chosenNums[0];
    nxt_n = chosenNums[1];
  } else if(chosenNums.length === 1){
    cur_n = null;          // 현재번호 없음
    nxt_n = chosenNums[0]; // 채울 대상(학급번호 등)
  } else {
    // 번호 컬럼 없음 - nxt_n도 null
    cur_n = null;
    nxt_n = null;
  }

  return {
    nameIdx,
    cur_g: gradeIdxs[0], cur_c: classIdxs[0], cur_n,
    nxt_g: gradeIdxs[1], nxt_c: classIdxs[1], nxt_n,
    hasNumColumn, // 번호 컬럼 존재 여부 플래그 추가
    colNames: {
      name: headers[nameIdx],
      cur_g: headers[gradeIdxs[0]], cur_c: headers[classIdxs[0]],
      cur_n: (cur_n === null ? "(없음)" : headers[cur_n]),
      nxt_g: headers[gradeIdxs[1]], nxt_c: headers[classIdxs[1]], 
      nxt_n: (nxt_n === null ? "(없음)" : headers[nxt_n]),
    }
  };
}

/* =========================
   6) 학교 진급명렬에서 학생이름 추출
========================= */
function extractNameKeys(name) {
  const nameKeys = new Set();
  const trimmedName = String(name || '').trim();
  if (!trimmedName) return nameKeys;
  
  // 1. 전체 이름 추가 (공백 제거)
  nameKeys.add(normCol(trimmedName));
  
  // 2. 괄호가 있는 경우 처리
  const parenMatch = trimmedName.match(/^(.+?)\s*\(([^)]+)\)$/);
  if (parenMatch) {
    const beforeParen = parenMatch[1].trim(); // 괄호 앞 (예: "YE SHUTONG" 또는 "홍길동")
    const insideParen = parenMatch[2].trim(); // 괄호 안 (예: "예수퉁" 또는 "HONG GILDONG")
    
    // 괄호 앞 이름 추가 (공백 있는 버전과 없는 버전 모두)
    nameKeys.add(normCol(beforeParen));
    nameKeys.add(beforeParen.toUpperCase().replace(/\s+/g, '')); // 공백 제거 버전
    
    // 괄호 안 이름 추가 (공백 있는 버전과 없는 버전 모두)
    nameKeys.add(normCol(insideParen));
    nameKeys.add(insideParen.toUpperCase().replace(/\s+/g, '')); // 공백 제거 버전
  }
  
  // 3. 영문명 공백 제거 버전도 추가 (공백 유무 관계없이 매칭)
  const upperName = trimmedName.toUpperCase().replace(/\s+/g, '');
  nameKeys.add(upperName);
  
  return nameKeys;
}

/* =========================
   7) 학년 추출 (통합학교 지원: 초등/중학/중등/고등/전공)
========================= */
function extractGrade(gradeStr) {
  const str = String(gradeStr || '').trim();
  if (!str) return null;
  
  // "진급"만 있는 경우 (졸업 처리용)
  if (str === "진급" || str === "졸업") {
    return "졸업";
  }
  
  // 1. 통합학교 형식 감지: "초등 1학년", "중학 2학년", "고등 3학년", "전공 1학년" 등
  const integratedMatch = str.match(/(초등|중학|중등|고등|전공)\s*(\d+)\s*학년/);
  if (integratedMatch) {
    const schoolLevel = integratedMatch[1];
    const gradeNum = parseInt(integratedMatch[2], 10);
    return `${schoolLevel} ${gradeNum}학년`; // "초등 1학년", "중학 2학년" 등
  }
  
  // 2. 연도 패턴 제거 (일반 학교용)
  let cleaned = str
    .replace(/20\d{2}\s*학년도?/g, ' ')
    .replace(/20\d{2}\s*년/g, ' ')
    .replace(/2[0-9]\s*학년도?/g, ' ')
    .replace(/2[0-9]\s*년/g, ' ')
    .replace(/^20\d{2}\s+/g, ' ')
    .replace(/^2[0-9]\s+/g, ' ')
    .trim();
  
  // 3. 정리된 문자열에서 "N학년" 패턴 찾기 (N이 1-6)
  const gradePattern = cleaned.match(/([1-6])\s*학년/);
  if (gradePattern) {
    return parseInt(gradePattern[1], 10);
  }
  
  // 4. "학년" 없이 단독 숫자 1-6 찾기
  const smallNum = cleaned.match(/(?:^|[^\d])([1-6])(?:[^\d]|$)/);
  if (smallNum) {
    return parseInt(smallNum[1], 10);
  }
  
  // 5. 모든 숫자 중 1-6 범위 찾기
  const allNumbers = cleaned.match(/\d+/g);
  if (allNumbers) {
    for (const num of allNumbers) {
      const n = parseInt(num, 10);
      if (n >= 1 && n <= 6) {
        return n;
      }
    }
  }
  
  return null;
}

// 학년 원본 값 추출 (진급학년용 - 숫자 변환 없이 원본 유지)
function extractGradeRaw(gradeStr) {
  const str = String(gradeStr || '').trim();
  if (!str) return null;
  
  // "진급"/"졸업"만 있는 경우 null 반환 (채우지 않음)
  if (str === "진급" || str === "졸업") {
    return null;
  }
  
  // 통합학교 형식: "초등 1학년", "중학 2학년" 등 그대로 반환
  const integratedMatch = str.match(/(초등|중학|중등|고등|전공)\s*(\d+)\s*학년?/);
  if (integratedMatch) {
    return `${integratedMatch[1]} ${integratedMatch[2]}학년`;
  }
  
  // "N학년" 형태 -> 숫자 추출하여 "N학년" 형식으로 반환
  const gradeMatch = str.match(/(\d+)\s*학년/);
  if (gradeMatch) {
    return `${gradeMatch[1]}학년`;
  }
  
  // 단순 숫자만 있는 경우 -> "N학년" 형식으로 반환
  const numOnly = str.match(/^(\d+)$/);
  if (numOnly) {
    return `${numOnly[1]}학년`;
  }
  
  // 그 외에 숫자가 포함된 경우 숫자 추출
  const anyNum = str.match(/(\d+)/);
  if (anyNum) {
    return `${anyNum[1]}학년`;
  }
  
  return str;
}

// 매칭용 학년 키 생성 (학교급 + 학년을 정규화)
function normalizeGradeKey(grade) {
  if (grade === null || grade === undefined) return "-1";
  if (grade === "졸업") return "졸업";
  
  // 문자열 형태 (통합학교: "초등 1학년", "중학 2학년" 등)
  if (typeof grade === 'string') {
    // 이미 정규화된 형태면 그대로 사용
    const match = grade.match(/(초등|중학|중등|고등|전공)\s*(\d+)/);
    if (match) {
      // 중등과 중학을 동일하게 처리
      const level = match[1] === "중등" ? "중학" : match[1];
      return `${level}_${match[2]}`;
    }
    return grade;
  }
  
  // 숫자 형태 (일반 학교)
  return String(grade);
}

// 졸업학년 여부 판정
function isGraduationGrade(grade, graduationGrades) {
  if (grade === null || grade === undefined) return false;
  if (grade === "졸업") return true;
  
  const gKey = normalizeGradeKey(grade);
  return graduationGrades.includes(gKey);
}

/* =========================
   8) 반 추출 (숫자 또는 한글 반 지원)
========================= */
function extractClass(classStr) {
  const str = String(classStr || '').trim();
  if (!str) return null;
  
  // 1. 숫자 반 (1, 2, 3 또는 "1반", "2반" 등)
  const numMatch = str.match(/(\d+)\s*반?/);
  if (numMatch) {
    return parseInt(numMatch[1], 10);
  }
  
  // 2. 한글 반 (가, 나, 다, 라, 마, 바, 사 등)
  const koreanClassMatch = str.match(/([가나다라마바사아자차카타파하])\s*반?/);
  if (koreanClassMatch) {
    return koreanClassMatch[1]; // 한글 문자 그대로 반환
  }
  
  // 3. 단독 숫자
  const singleNum = str.match(/\d+/);
  if (singleNum) {
    return parseInt(singleNum[0], 10);
  }
  
  // 4. 단독 한글 반 문자
  const singleKorean = str.match(/^[가나다라마바사아자차카타파하]$/);
  if (singleKorean) {
    return singleKorean[0];
  }
  
  return null;
}

// 진급반 원본 값 추출 (숫자로 변환하지 않고 원본 유지)
function extractClassRaw(classStr) {
  const str = String(classStr || '').trim();
  if (!str) return null;
  
  // "N반" 형태에서 N 추출 (숫자 또는 한글)
  const classMatch = str.match(/^(\d+|[가나다라마바사아자차카타파하])\s*반?$/);
  if (classMatch) {
    return classMatch[1];
  }
  
  // 그냥 숫자나 한글 문자만 있는 경우
  if (/^\d+$/.test(str)) {
    return str;
  }
  if (/^[가나다라마바사아자차카타파하]$/.test(str)) {
    return str;
  }
  
  // 원본 그대로 반환
  return str;
}

/* =========================
   9) 번호 추출
========================= */
function extractNo(noStr) {
  const noMatch = noStr.match(/\d+/);
  return noMatch ? parseInt(noMatch[0], 10) : null;
}

/* =========================
   10) 상태 설정
========================= */
function setStatus(status) {
  document.getElementById('runStatus').innerHTML = status;
}

function checkFilesAndEnableRun() {
  const schoolFile = document.getElementById('schoolFile').files[0];
  const ealimiFile = document.getElementById('ealimiFile').files[0];
  document.getElementById('runBtn').disabled = !(schoolFile && ealimiFile);
}

document.getElementById('schoolFile').addEventListener('change', async function() {
  const file = this.files[0];
  const infoEl = document.getElementById('schoolInfo');
  
  if (file) {
    infoEl.innerHTML = '<span style="color:#666;">파일 검증 중...</span>';
    try {
      const data = await parseFile(file);
      const colCount = data.headers.length;
      
      if (colCount < 7) {
        infoEl.innerHTML = `<span class="err">오류: 컬럼이 ${colCount}개입니다. 진급명렬은 7개 컬럼이 필요합니다.<br/>(학생이름, 이전학년, 이전반, 이전번호, 진급학년, 진급반, 진급번호)</span>`;
        this.value = ''; // 파일 선택 해제
        checkFilesAndEnableRun();
        return;
      }
      
      infoEl.innerHTML = `<span class="ok">파일 선택됨: ${file.name} (${colCount}개 컬럼, ${data.rows.length}행)</span>`;
    } catch (err) {
      infoEl.innerHTML = `<span class="err">오류: 파일을 읽을 수 없습니다. (${err.message})</span>`;
      this.value = '';
    }
  } else {
    infoEl.innerHTML = '';
  }
  checkFilesAndEnableRun();
});

document.getElementById('ealimiFile').addEventListener('change', async function() {
  const file = this.files[0];
  const infoEl = document.getElementById('ealimiInfo');
  
  if (file) {
    infoEl.innerHTML = '<span style="color:#666;">파일 검증 중...</span>';
    try {
      const data = await parseFile(file);
      const headers = data.headers;
      
      // 학년/반 컬럼 개수 확인
      let gradeCount = 0;
      let classCount = 0;
      
      for (const h of headers) {
        const nc = normCol(h);
        if (nc.includes("학년") && !nc.includes("신") && !nc.includes("학년도")) gradeCount++;
        if (nc.includes("반") && !nc.includes("신") && !nc.includes("반장")) classCount++;
      }
      
      if (gradeCount < 2 || classCount < 2) {
        infoEl.innerHTML = `<span class="err">오류: 학년 컬럼 ${gradeCount}개, 반 컬럼 ${classCount}개 감지됨.<br/>e알리미 양식은 학년/반 컬럼이 각각 2개 이상 필요합니다.</span>`;
        this.value = '';
        checkFilesAndEnableRun();
        return;
      }
      
      infoEl.innerHTML = `<span class="ok">파일 선택됨: ${file.name} (학년 ${gradeCount}개, 반 ${classCount}개 컬럼, ${data.rows.length}행)</span>`;
    } catch (err) {
      infoEl.innerHTML = `<span class="err">오류: 파일을 읽을 수 없습니다. (${err.message})</span>`;
      this.value = '';
    }
  } else {
    infoEl.innerHTML = '';
  }
  checkFilesAndEnableRun();
});

document.getElementById('resetBtn').addEventListener('click', function() {
  document.getElementById('schoolFile').value = '';
  document.getElementById('ealimiFile').value = '';
  document.getElementById('schoolInfo').innerHTML = '';
  document.getElementById('ealimiInfo').innerHTML = '';
  document.getElementById('runBtn').disabled = true;
  document.getElementById('dlUpload').disabled = true;
  document.getElementById('dlReport').disabled = true;
  document.getElementById('dlMissing').disabled = true;
  document.getElementById('dlRollback').disabled = true;
  setStatus('대기 중');
  document.getElementById('resultSummary').innerHTML = '실행 후 결과 요약이 표시됩니다.';
  document.getElementById('previewArea').innerHTML = '';
});

/* =========================
   11) 메인 로직
========================= */
document.getElementById('runBtn').addEventListener('click', async () => {
  const schoolFile = document.getElementById('schoolFile').files[0];
  const ealimiFile = document.getElementById('ealimiFile').files[0];

  if (!schoolFile || !ealimiFile) {
    setStatus('<span class="err">파일을 모두 업로드해주세요.</span>');
    return;
  }

  setStatus('<span class="ok">진행 중...</span>');

  try {
    const schoolData = await parseFile(schoolFile);
    const ealimiData = await parseFile(ealimiFile);

    const headers0 = schoolData.headers;
    const dataRows0 = schoolData.rows;
    const headers1 = ealimiData.headers;
    const dataRows1 = ealimiData.rows;

    const pos = findEalimiColumns(headers1);
    
    const fullLookup = new Map();
    const partLookup = new Map();
    
    for (let i = 0; i < dataRows0.length; i++) {
      const row = dataRows0[i];
      // row가 배열인지 확인
      if (!Array.isArray(row)) continue;
      
      // 7개 컬럼까지 패딩
      while (row.length < 7) row.push("");
      
const name = clean(row[0]);
  // 통합학교 형식("초등 1학년", "중학 2학년" 등)도 지원
  const prevGrade = extractGrade(String(row[1] || ''));
  const prevClass = extractClass(String(row[2] || ''));
  const prevNum = extractNo(String(row[3] || ''));
  const nextGradeRaw = extractGradeRaw(String(row[4] || '')); // 진급학년은 원본 값 유지
  const nextClass = extractClassRaw(String(row[5] || '')); // 진급반은 원본 값 유지 (가, 나, 다 등)
  const nextNum = extractNo(String(row[6] || ''));
  
  if (!name) continue;
  // 졸업인 경우도 유효 (nextGradeRaw가 null이 됨)
  if (prevGrade === null && prevGrade !== "졸업" && nextGradeRaw === null) continue;
      
const nameKeys = extractNameKeys(name);
  // 매칭용 학년 키 (통합학교: "초등_1", "중학_2" 등 / 일반학교: "1", "2" 등)
  const gKey = normalizeGradeKey(prevGrade);
  const c = prevClass !== null ? prevClass : -1;
  
  const studentData = {
  "_rowId": i,
  "학생이름": name,
  "이전학년": prevGrade,
  "이전반": prevClass,
  "이전번호": prevNum,
  "진급학년": nextGradeRaw, // 원본 값 유지 ("초등 2학년", "중학 1학년" 등)
  "진급반": nextClass,
  "진급번호": nextNum
  };
  
  for (const nk of nameKeys) {
  // 번호 포함 키
  if (prevNum !== null) {
  const keyFull = `${nk}_${gKey}_${c}_${prevNum}`;
  if (!fullLookup.has(keyFull)) {
  fullLookup.set(keyFull, studentData);
  }
  }
  // 번호 미포함 키
  const keyPart = `${nk}_${gKey}_${c}`;
  if (!partLookup.has(keyPart)) {
  partLookup.set(keyPart, studentData);
  }
  }
  }
    
// fullLookup/partLookup 생성 완료
    
    // 학교 진급명렬에 진급번호가 있는지 확인
    const hasSchoolNextNum = dataRows0.some(r => Array.isArray(r) && r.length >= 7 && toIntOrNull(r[6]) !== null);
    // 양쪽 조건 모두 만족해야 번호를 채움
    const shouldFillNumber = pos.hasNumColumn && pos.nxt_n !== null && hasSchoolNextNum;

    // 3) 매칭 + 채우기
    const report = [];
    const eOutRows = [];
    const matchedSchoolRowIds = new Set();
    
// 졸업학년 판정 (통합학교 지원)
  // 학교 유형 감지: 통합학교(초등/중학/고등/전공) vs 일반학교(1-6학년)
  let schoolType = "일반"; // "일반" 또는 "통합"
  let hasIntegratedGrade = false;
  let has4or5Grade = false;
  
  for (const row of dataRows1) {
    if (!Array.isArray(row)) continue;
    const gStr = String(row[pos.cur_g] || '');
    const g = extractGrade(gStr);
    
    // 통합학교 형식 감지
    if (typeof g === 'string' && (g.includes('초등') || g.includes('중학') || g.includes('중등') || g.includes('고등') || g.includes('전공'))) {
      hasIntegratedGrade = true;
    }
    
    // 일반학교 4/5학년 감지
    if (typeof g === 'number' && (g === 4 || g === 5)) {
      has4or5Grade = true;
    }
  }
  
  // 통합학교는 각 학교급의 최고 학년이 졸업학년
  // 일반학교는 4/5학년 존재 여부로 결정
  let graduationGrades = []; // 졸업학년 목록
  let graduationGradeDisplay = "";
  
  if (hasIntegratedGrade) {
    schoolType = "통합";
    // 통합학교: 초등6, 중학3, 고등3, 전공2가 졸업학년
    graduationGrades = ["초등_6", "중학_3", "중등_3", "고등_3", "전공_2"];
    graduationGradeDisplay = "초등6/중학3/고등3/전공2";
  } else {
    schoolType = "일반";
    // 일반학교: 4/5학년 있으면 6학년, 없으면 3학년
    const maxGrade = has4or5Grade ? 6 : 3;
    graduationGrades = [String(maxGrade)];
    graduationGradeDisplay = `${maxGrade}학년`;
  }
    
    let graduationCount = 0;
    
    for(let i=0;i<dataRows1.length;i++){
      const row = (dataRows1[i] || []).slice();
      while(row.length < headers1.length) row.push("");
      
      const rawName = row[pos.nameIdx];
      const nameKeys = Array.from(extractNameKeys(rawName || ''));
      
const g = extractGrade(String(row[pos.cur_g] || ''));
  const c = extractClass(String(row[pos.cur_c] || ''));
  const n = (pos.cur_n === null ? null : extractNo(String(row[pos.cur_n] || '')));
  
  // 매칭용 키 생성 (통합학교 지원)
  const gKey = normalizeGradeKey(g);
  const c2 = (c !== null && c !== undefined) ? c : -1;
  
let status = "미매칭";
  let matched = null;
  
  // 졸업학년 여부 확인 (나중에 매칭 결과에 따라 졸업/진급 결정)
  const isPotentialGraduation = (g === "졸업" || isGraduationGrade(g, graduationGrades));
  
  // 1. 먼저 매칭 시도 (번호 포함)
  if(n !== null && nameKeys.length){
  for(const nk of nameKeys){
  const kf = `${nk}_${gKey}_${c2}_${n}`;
  if(fullLookup.has(kf)){
  matched = fullLookup.get(kf);
  status = "매칭(번호포함-이름확장)";
  break;
  }
  }
  }
  
  // 2. 번호 없이 매칭 시도
  if(!matched && nameKeys.length){
  for(const nk of nameKeys){
  const kp = `${nk}_${gKey}_${c2}`;
  if(partLookup.has(kp)){
  matched = partLookup.get(kp);
  status = "매칭(번호없음-이름확장)";
  break;
  }
  }
  }
  
  // 3. 졸업 판정: 졸업학년이고 매칭되지 않았거나, 매칭되었어도 진급학년/반 데이터가 없는 경우
  if (isPotentialGraduation) {
    if (!matched) {
      // 매칭 안 됨 -> 졸업
      graduationCount++;
      status = "졸업";
    } else {
      // 매칭됨 -> 진급 데이터 확인
      const hasNextGrade = matched["진급학년"] !== null && matched["진급학년"] !== undefined && matched["진급학년"] !== "";
      const hasNextClass = matched["진급반"] !== null && matched["진급반"] !== undefined && matched["진급반"] !== "";
      
      if (!hasNextGrade && !hasNextClass) {
        // 진급 데이터 없음 -> 졸업 (매칭은 됐지만 진급정보 없음)
        graduationCount++;
        status = "졸업";
        matched = null; // 매칭 취소
      }
      // else: 진급 데이터 있음 -> 진급으로 처리 (status는 이미 "매칭..."으로 설정됨)
    }
  }
  
  if(!nameKeys.length && status !== "졸업") status = "미매칭(이름키없음)";
      
if(matched){
  // 진급학년: e알리미 원본 학년 형식을 참조하여 연도만 "26년"으로 교체
  const rawGrade = matched["진급학년"];
  const originalGradeCol = String(row[pos.cur_g] || ''); // e알리미 원본 학년 컬럼
  
  if (rawGrade !== null && rawGrade !== undefined && rawGrade !== "") {
    const gradeStr = String(rawGrade);
    // 진급명렬에서 진급학년 숫자 추출
    const gradeNumMatch = gradeStr.match(/(\d+)/);
    const newGradeNum = gradeNumMatch ? gradeNumMatch[1] : null;
    
    // 통합학교 형식 확인: "초등 2학년", "중학 1학년" 등
    const integratedMatch = gradeStr.match(/(초등|중학|중등|고등|전공)\s*(\d+)/);
    
    if (integratedMatch) {
      // 통합학교: "26년 초등 2학년" 형식
      row[pos.nxt_g] = `26년 ${integratedMatch[1]} ${integratedMatch[2]}학년`;
    } else if (newGradeNum && originalGradeCol) {
      // 일반학교: e알리미 원본 형식에서 연도를 26년으로, 학년을 진급학년으로 교체
      // 예: "2025년도 3학년 학생" -> "26년 4학년 학생"
      // 예: "25 3학년 학부모" -> "26년 4학년 학부모"
      
      let formatted = originalGradeCol;
      
// 1. 연도 패턴 교체: 202x년도, 202x년, 202x, 2x년도, 2x년, 2x -> "26년"
  formatted = formatted
  .replace(/20\d{2}\s*년도\s*/g, '26년 ')   // "2025년도 ", "2026년도 "
  .replace(/20\d{2}\s*년\s*/g, '26년 ')     // "2025년 ", "2026년 "
  .replace(/20\d{2}\s+/g, '26년 ')          // "2025 ", "2026 " (뒤에 공백)
  .replace(/2[0-9]\s*년도\s*/g, '26년 ')    // "25년도 ", "26년도 "
  .replace(/2[0-9]\s*년\s*/g, '26년 ')      // "25년 ", "26년 "
  .replace(/2[0-9]\s+(?=\d학년)/g, '26년 '); // "25 3학년" -> "26년 3학년"
  
  // 2. 학년 숫자 교체: N학년 -> 진급학년
  formatted = formatted.replace(/(\d+)\s*학년/, `${newGradeNum}학년`);
  
  // 3. 연도가 아예 없던 경우 (예: "3학년 학부모") -> "26년 " 접두어 추가
  if (!formatted.includes('26년')) {
  formatted = '26년 ' + formatted;
  }
  
  // 4. 공백 정리
  formatted = formatted.replace(/\s+/g, ' ').trim();
  
  // 5. 최종 확인: "2026년" 또는 기타 연도가 남아있으면 "26년"으로 통일
  formatted = formatted.replace(/20\d{2}년/g, '26년').replace(/2[0-9]년/g, '26년');
      
      row[pos.nxt_g] = formatted;
    } else {
      // 폴백: 그냥 "26년 N학년" 형식
      row[pos.nxt_g] = newGradeNum ? `26년 ${newGradeNum}학년` : gradeStr;
    }
  } else {
    row[pos.nxt_g] = "";
  }
  
  // 진급반: "N반" 형식으로 포맷팅
  const rawClass = matched["진급반"];
  if (rawClass !== null && rawClass !== undefined && rawClass !== "") {
    // 이미 "반"이 포함되어 있으면 그대로, 아니면 "반" 추가
    const classStr = String(rawClass);
    row[pos.nxt_c] = classStr.includes("반") ? classStr : `${classStr}반`;
  } else {
    row[pos.nxt_c] = "";
  }
  
  if(shouldFillNumber && pos.nxt_n !== null){
  row[pos.nxt_n] = matched["진급번호"] ?? "";
  }
  matchedSchoolRowIds.add(matched["_rowId"]);
  }
      
      report.push({
        "학생이름(원본)": rawName ?? "",
        "현재학년(원본)": row[pos.cur_g] ?? "",
        "현재반(원본)": row[pos.cur_c] ?? "",
        "현재번호(원본)": (pos.cur_n===null ? "" : (row[pos.cur_n] ?? "")),
        "파싱학년": (g===null? "" : g),
        "파싱반": (c===null? "" : c),
        "파싱번호": (n===null? "" : n),
        "상태": status
      });
      
      eOutRows.push(row);
    }
    
    const total = dataRows1.length;
    const matchedCount = report.filter(r => startsWithMatched(r["상태"])).length;
    const unmatchedCount = total - matchedCount - graduationCount;
    
setStatus(`<span class="ok">완료</span> | 학교유형: <b>${schoolType}</b> | 졸업학년: <b>${graduationGradeDisplay}</b> | 총 ${total}건 / 매칭 ${matchedCount}건 / 미매칭 ${unmatchedCount}건 / 졸업 ${graduationCount}건${shouldFillNumber ? "" : " | <span style='color:#666;'>번호컬럼 미채움</span>"}`);
  document.getElementById('resultSummary').innerHTML = `
  <div><b>완료</b></div>
  <div>학교유형: <b>${schoolType}</b> | 졸업학년: <b>${graduationGradeDisplay}</b></div>
  <div>총 <b>${total}</b>건 / 매칭 <b>${matchedCount}</b>건 / 미매칭 <b>${unmatchedCount}</b>건 / 졸업 <b>${graduationCount}</b>건</div>
  ${shouldFillNumber ? "" : "<div class='small' style='color:#888;'>※ e알리미 양식에 번호컬럼이 없거나, 진급명렬에 진급번호가 없어 번호는 채우지 않았습니다.</div>"}
  <div class="small" style="margin-top:8px;">
  인식된 e알리미 컬럼: 이름(${clean(pos.colNames.name)}), 현재(${clean(pos.colNames.cur_g)} / ${clean(pos.colNames.cur_c)} / ${clean(pos.colNames.cur_n)}), 채움대상(${clean(pos.colNames.nxt_g)} / ${clean(pos.colNames.nxt_c)} / ${clean(pos.colNames.nxt_n)})
  </div>
  `;

    const missingFromSchool = [];
    for (let i = 0; i < dataRows0.length; i++) {
      if (!matchedSchoolRowIds.has(i)) {
        const row = dataRows0[i];
        if (Array.isArray(row) && row.length >= 1 && clean(row[0])) {
          missingFromSchool.push(row);
        }
      }
    }

    const timestamp = nowStamp();
    const uploadHeaders = headers1.map(stripPandasDupSuffix);
    const reportHeaders = Object.keys(report[0] || {});
    const schoolHeaders = headers0.map(stripPandasDupSuffix);
    
    // 매칭된 행만 필터링
    const matchedRows = eOutRows.filter((r, idx) => startsWithMatched(report[idx]["상태"]));
    
    let rollbackHeaders = uploadHeaders.slice();
    let rollbackRows = [];
    
    if (pos.nxt_n !== null && pos.cur_n === null) {
      // 번호 컬럼이 뒤쪽에만 있는 경우 - 컬럼 재배열 필요
      // 번호 컬럼을 nxt_n 위치에서 cur_c+1 위치로 이동
      const numColIdx = pos.nxt_n;
      const insertIdx = pos.cur_c + 1; // 현재반 다음 위치
      
      // 헤더 재배열
      const numHeader = rollbackHeaders[numColIdx];
      rollbackHeaders.splice(numColIdx, 1); // 기존 위치에서 제거
      rollbackHeaders.splice(insertIdx, 0, numHeader); // 새 위치에 삽입
      
      rollbackRows = matchedRows.map(row => {
        const newRow = row.slice();
        
        // 1. 값 교환 (학년, 반)
        const tempG = newRow[pos.cur_g];
        const tempC = newRow[pos.cur_c];
        newRow[pos.cur_g] = newRow[pos.nxt_g];
        newRow[pos.cur_c] = newRow[pos.nxt_c];
        newRow[pos.nxt_g] = tempG;
        newRow[pos.nxt_c] = tempC;
        
        // 2. 번호 컬럼 위치 재배열
        const numValue = newRow[numColIdx];
        newRow.splice(numColIdx, 1); // 기존 위치에서 제거
        newRow.splice(insertIdx, 0, numValue); // 새 위치에 삽입
        
        return newRow;
      });
    } else {
      // 번호 컬럼이 양쪽에 있거나 없는 경우 - 기존 로직 (값만 교환)
      rollbackRows = matchedRows.map(row => {
        const newRow = row.slice();
        // 학년 교환
        const tempG = newRow[pos.cur_g];
        newRow[pos.cur_g] = newRow[pos.nxt_g];
        newRow[pos.nxt_g] = tempG;
        // 반 교환
        const tempC = newRow[pos.cur_c];
        newRow[pos.cur_c] = newRow[pos.nxt_c];
        newRow[pos.nxt_c] = tempC;
        // 번호 교환 (두 개 다 있으면)
        if (pos.cur_n !== null && pos.nxt_n !== null) {
          const tempN = newRow[pos.cur_n];
          newRow[pos.cur_n] = newRow[pos.nxt_n];
          newRow[pos.nxt_n] = tempN;
        }
        return newRow;
      });
    }
    
    // 헤더: 구분, 학생이름, 현재학년, 현재반, 현재번호, 파싱학년, 파싱반, 파싱번호, 상태, 이전학년, 이전반, 이전번호, 진급학년, 진급반, 진급번호
    const missingHeaders = ["구분", "학생이름", "현재학년", "현재반", "현재번호", "파싱학년", "파싱반", "파싱번호", "상태", "이전학년", "이전반", "이전번호", "진급학년", "진급반", "진급번호"];
    const missingRows = [];
    
    // 1) e알리미 명단 중 누락 (미매칭이며 졸업생 제외)
    for (let i = 0; i < report.length; i++) {
      const r = report[i];
      const status = r["상태"];
      if (status === "졸업") continue;
      if (!startsWithMatched(status)) {
        missingRows.push([
          "e알리미 명단 중 누락",
          r["학생이름(원본)"] ?? "",
          r["현재학년(원본)"] ?? "",
          r["현재반(원본)"] ?? "",
          r["현재번호(원본)"] ?? "",
          r["파싱학년"] ?? "",
          r["파싱반"] ?? "",
          r["파싱번호"] ?? "",
          r["상태"] ?? "",
          "", "", "", "", "", "" // 이전학년~진급번호는 빈칸
        ]);
      }
    }
    
    // 2) 진급명렬 중 누락 (진급명렬에 있으나 양식에서 매칭되지 않은 학생)
    for (let i = 0; i < dataRows0.length; i++) {
      if (!matchedSchoolRowIds.has(i)) {
        const row = dataRows0[i];
        if (Array.isArray(row) && row.length >= 1 && clean(row[0])) {
          // row 구조: [학생이름, 이전학년, 이전반, 이전번호, 진급학년, 진급반, 진급번호]
          while(row.length < 7) row.push("");
          missingRows.push([
            "진급명렬 중 누락",
            row[0] ?? "", // 학생이름
            "", "", "", // 현재학년, 현재반, 현재번호 (e알리미에 없으므로 빈칸)
            "", "", "", // 파싱학년, 파싱반, 파싱번호 (e알리미에 없으므로 빈칸)
            "미매칭(양식에 없음/불일치)",
            row[1] ?? "", // 이전학년
            row[2] ?? "", // 이전반
            row[3] ?? "", // 이전번호
            row[4] ?? "", // 진급학년
            row[5] ?? "", // 진급반
            row[6] ?? ""  // 진급번호
          ]);
        }
      }
    }

    // 다운로드 버튼 이벤트 설정
    const dlUploadBtn = document.getElementById('dlUpload');
    const dlReportBtn = document.getElementById('dlReport');
    const dlMissingBtn = document.getElementById('dlMissing');
    const dlRollbackBtn = document.getElementById('dlRollback');
    
    dlUploadBtn.disabled = false;
    dlReportBtn.disabled = false;
    dlMissingBtn.disabled = false;
    dlRollbackBtn.disabled = false;
    
    dlUploadBtn.onclick = () => {
      const filtered = removeEmptyColumns(uploadHeaders, matchedRows);
      downloadCsv(`진급_업로드용(매칭행만)_${timestamp}.csv`, filtered.rows, filtered.headers, false);
    };
    dlReportBtn.onclick = () => downloadCsv(`진급_매칭리포트_${timestamp}.csv`, report, reportHeaders, true);
    dlMissingBtn.onclick = () => downloadCsv(`진급누락목록_${timestamp}.csv`, missingRows, missingHeaders, true);
    dlRollbackBtn.onclick = () => {
      const filtered = removeEmptyColumns(rollbackHeaders, rollbackRows);
      downloadCsv(`진급_롤백용_${timestamp}.csv`, filtered.rows, filtered.headers, false);
    };

    let previewHtml = '<h4>업로드용(매칭행만) 상위 5행</h4>';
    previewHtml += '<table><thead><tr>';
    uploadHeaders.forEach(h => previewHtml += `<th>${h}</th>`);
    previewHtml += '</tr></thead><tbody>';
    matchedRows.slice(0, 5).forEach(row => {
      previewHtml += '<tr>';
      row.forEach(cell => previewHtml += `<td>${cell ?? ''}</td>`);
      previewHtml += '</tr>';
    });
    previewHtml += '</tbody></table>';
    
    previewHtml += '<h4 style="margin-top:12px;">누락목록 상위 10행</h4>';
    previewHtml += '<table><thead><tr>';
    missingHeaders.forEach(h => previewHtml += `<th>${h}</th>`);
    previewHtml += '</tr></thead><tbody>';
    missingRows.slice(0, 10).forEach(row => {
      previewHtml += '<tr>';
      if (Array.isArray(row)) {
        row.forEach(cell => previewHtml += `<td>${cell ?? ''}</td>`);
      }
      previewHtml += '</tr>';
    });
    previewHtml += '</tbody></table>';
    
    document.getElementById('previewArea').innerHTML = previewHtml;

  } catch (err) {
    setStatus(`<span class="err">오류: ${err.message}</span>`);
    console.error('[v0] Error:', err);
  }
});

async function parseFile(file) {
  return new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = (e) => {
  try {
  const data = new Uint8Array(e.target.result);
  const isCSV = file.name.toLowerCase().endsWith('.csv');
  
  let workbook;
  if (isCSV) {
    // CSV 파일: EUC-KR 인코딩 시도
    const decoder = new TextDecoder('euc-kr');
    const textEucKr = decoder.decode(data);
    
    // UTF-8로도 시도
    const decoderUtf8 = new TextDecoder('utf-8');
    const textUtf8 = decoderUtf8.decode(data);
    
    // 한글이 제대로 디코딩되었는지 확인 (깨진 문자 여부)
    const hasValidKoreanEucKr = /[가-힣]/.test(textEucKr);
    const hasValidKoreanUtf8 = /[가-힣]/.test(textUtf8);
    const hasGarbageUtf8 = /[\uFFFD]/.test(textUtf8) || /[Ã¤Ã¥Ã¦Ã§Ã¨Ã©]/.test(textUtf8);
    
    // EUC-KR이 한글을 포함하고, UTF-8이 깨졌거나 한글이 없으면 EUC-KR 사용
    const text = (hasValidKoreanEucKr && (!hasValidKoreanUtf8 || hasGarbageUtf8)) ? textEucKr : textUtf8;
    
    workbook = XLSX.read(text, { type: 'string' });
  } else {
    // Excel 파일: 기본 처리
    workbook = XLSX.read(data, { type: 'array' });
  }
  
  const sheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[sheetName];
  const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
  
  let headerRowIdx = 0;
  
  // 헤더 행 찾기: 키워드 포함 + 충분한 컬럼 수 (병합된 제목 행 무시)
  for (let i = 0; i < Math.min(json.length, 15); i++) {
    const row = json[i];
    if (!row) continue;
    
    // 유효한 컬럼 개수 (빈 값이 아닌 컬럼)
    const validColCount = row.filter(cell => cell !== null && cell !== undefined && String(cell).trim() !== '').length;
    
    // 3개 이상의 유효한 컬럼이 있어야 헤더 행으로 인정
    if (validColCount < 3) continue;
    
    const rowStr = row.join(' ').toLowerCase();
    if (rowStr.includes('이름') || rowStr.includes('학생') || rowStr.includes('성명') || rowStr.includes('학년') || rowStr.includes('번호')) {
      headerRowIdx = i;
      break;
    }
  }
  
  // 키워드로 못 찾았으면 7개 이상 컬럼이 있는 첫 번째 행을 헤더로 사용 (진급명렬용)
  if (headerRowIdx === 0) {
    for (let i = 0; i < Math.min(json.length, 15); i++) {
      const row = json[i];
      if (!row) continue;
      const validColCount = row.filter(cell => cell !== null && cell !== undefined && String(cell).trim() !== '').length;
      if (validColCount >= 7) {
        headerRowIdx = i;
        break;
      }
    }
  }
        
  const headers = json[headerRowIdx] || [];
  const rows = json.slice(headerRowIdx + 1).filter(row => row && row.length > 0);
  
  resolve({ headers, rows });
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

function downloadCsv(filename, rows, headers, withBom){
  let csv;
  if (Array.isArray(rows) && rows.length > 0 && Array.isArray(rows[0])) {
    const data = [headers, ...rows];
    csv = Papa.unparse(data, { quotes: false });
  } else {
    csv = Papa.unparse(rows, { quotes: false });
  }
  
  let blob;
  if (withBom) {
    // 리포트/누락목록: UTF-8 BOM 포함 (엑셀에서 UTF-8로 인식)
    const content = "\ufeff" + csv;
    blob = new Blob([content], {type:"text/csv;charset=utf-8;"});
  } else {
    const cp949Bytes = convertToCP949(csv);
    blob = new Blob([cp949Bytes], {type:"text/csv"});
  }
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

function downloadRollbackCsv(filename, rows, headers) {
  const rollbackRows = rows.map(row => {
    const newRow = [...row];
    const temp = newRow[headers.indexOf("학년")];
    newRow[headers.indexOf("학년")] = newRow[headers.indexOf("학년.1")];
    newRow[headers.indexOf("학년.1")] = temp;

    const tempClass = newRow[headers.indexOf("반")];
    newRow[headers.indexOf("반")] = newRow[headers.indexOf("반.1")];
    newRow[headers.indexOf("반.1")] = tempClass;

    const tempNum = newRow[headers.indexOf("번호")];
    newRow[headers.indexOf("번호")] = newRow[headers.indexOf("번호.1")];
    newRow[headers.indexOf("번호.1")] = tempNum;

    return newRow;
  });

  const timestamp = nowStamp();
  const rollbackHeaders = headers.map(stripPandasDupSuffix);
  
  const csv = Papa.unparse([rollbackHeaders, ...rollbackRows], { quotes: false });
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

function removeEmptyColumns(headers, rows) {
  // 각 컬럼별로 데이터가 있는지 확인
  const colHasData = headers.map((_, colIdx) => {
    return rows.some(row => {
      const val = row[colIdx];
      return val !== null && val !== undefined && String(val).trim() !== '';
    });
  });
  
  // 데이터가 있는 컬럼 인덱스만 추출
  const keepIndices = colHasData.map((has, idx) => has ? idx : -1).filter(idx => idx !== -1);
  
  // 새 헤더와 행 생성
  const newHeaders = keepIndices.map(idx => headers[idx]);
  const newRows = rows.map(row => keepIndices.map(idx => row[idx]));
  
  return { headers: newHeaders, rows: newRows };
}

</script>
</body>
</html>
